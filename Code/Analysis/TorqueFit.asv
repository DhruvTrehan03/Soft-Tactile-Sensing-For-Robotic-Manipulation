%% Preamble

% Toggle Settings

initialise = 0;
load_data = 1;       % Set to true to reload data
find_shift =  0;      % Set to true to find the best shift
opt = 1;


% Initialise EIDORS (Only really need to do this the first time you run eacch session)

if initialise
    clear
    load_data = 1;       % Set to true to reload data
    find_shift = 0;      % Set to true to find the best shift
    opt = 0;
    smooth_coeff = 50;
    run('Source/eidors-v3.11-ng/eidors/eidors_startup.m'); % Initialize EIDOR
     height = 0;
    width = 4.4;
    len = 3.6;
    xy = [0 0 width width; 0 len len 0]';
    curve_type = 1;
    maxsz = 0.1;

    trunk_shape = {height, xy, curve_type, maxsz};
    elec_pos  = [32, 1.1];
    elec_shape = 0.2;

    mdl = ng_mk_extruded_model(trunk_shape, elec_pos, elec_shape);
    stim = mk_stim_patterns(32, 1, [0, 16], [0, 1], {'no_meas_current'}, 5);
    plain = mk_image(mdl, 1, 'Hi');
    plain.fwd_model.stimulation = stim;
end

% Load Data (Only If Needed)
if load_data
    torqueVals = [];
    torqueIndexes = [];
    torqueData = [];
    data_objs = load("SavedVariables\TorqueSlice.mat").clipped_data';
    data_objs = data_objs(data_objs ~= 0); % Remove zero values
    data_homg = load("SavedVariables\TorqueSliceHom.mat").clipped_data_hom';
    data_homg = data_homg(data_homg ~= 0); % Remove zero values
    data_diff = abs(data_objs - data_homg);
    windowSize = 10;
    b = (1/windowSize)*ones(1,windowSize);
    a = 1;
    data_diff = filter(b,a,data_diff);

    data_diff = circshift(data_diff,615);
end

% Find Best Shift (If Needed)
if find_shift
    best_shift = find_best_shift_envelope(data_diff, sim_diff, 1, 896,smooth_coeff);
    data_diff = circshift(data_diff, best_shift);
    % data_diff = clip(2*circshift(data_diff,100),-1,0.05);
    
end


% Generate Models and Apply Function
centre = 1.8;

sigma = 0.3;
k = 5;
select_fcn = @(x,y,z) exp(-(y - centre).^2 / (2 * sigma^2)) .*(cos(k * (y-centre)));

% sigma = 1;
% select_fcn = @(x, y, z) -(y - centre) .* exp(-((y - centre).^2) / (2 * sigma^2)) / (sigma^2);


press = plain;
press.elem_data = 1 + elem_select(press.fwd_model, select_fcn);
press.fwd_model.stimulation = stim;

%% Plot Results
plain_data = fwd_solve(plain);
press_data = fwd_solve(press);
sim_diff = abs(press_data.meas - plain_data.meas);
sim_diff = sim_diff/10;
[correlation, env_data_diff_smooth,env_sim_diff_smooth] = envelope_correlation(data_diff, sim_diff,smooth_coeff);

subplot(3,1,1)
show_fem(press);
subplot(3,1,2);
    % plot(data_diff, 'b'); 
    hold on;  % Original data in blue
    plot(env_data_diff_smooth, 'r', 'LineWidth', 1.5); % Smoothed envelope in red
    hold off;
    title('Data Difference with Envelope');
    legend('Data Difference', 'Envelope');
subplot(3,1,3)
    % plot(sim_diff, 'b'); 
    hold on;  % Simulation difference in blue
    plot(env_sim_diff_smooth, 'r', 'LineWidth', 1.5); % Smoothed envelope in red
    hold off;
    title('Simulation Difference with Envelope');
    legend('Simulation Difference', 'Envelope');

if opt

% Define ranges for k and sigma
k_values = linspace(1, 10, 10);   % Adjust range as needed
sigma_values = linspace(0.1, 1, 10); % Adjust range as needed

% Optimize parameters
[best_k, best_sigma, best_corr] = optimize_parameters(data_diff, mdl, stim, k_values, sigma_values, smooth_coeff);

end



%% Functions

function best_shift = find_best_shift(data_diff, sim_diff, shift_step, max_shifts)
    biggest_cor = [0, 0]; % [correlation, shift index]
    corrs = zeros([max_shifts, 1]);

    for i = 1:max_shifts
        shifted_data = circshift(data_diff, i * shift_step);
        score = corr(shifted_data, sim_diff, 'Type', 'Spearman');
        corrs(i) = score;
        if score > biggest_cor(1)
            biggest_cor = [score, i];
        end
    end

    best_shift = biggest_cor(2) * shift_step;
    fprintf('Best shift: %d samples, Correlation: %.4f\n', best_shift, biggest_cor(1));
end

function best_shift = find_best_shift_dtw(data_diff, sim_diff, shift_step, max_shifts)
    min_dtw_dist = Inf; % Start with a very high DTW distance
    best_shift = 0;
    
    for i = 1:max_shifts
        shifted_data = circshift(data_diff, i * shift_step);
        dtw_dist = dtw(shifted_data, sim_diff); % Compute DTW distance
        if dtw_dist < min_dtw_dist
            min_dtw_dist = dtw_dist;
            best_shift = i * shift_step;
        end
    end

    fprintf('Best shift: %d samples (DTW distance: %.4f)\n', best_shift, min_dtw_dist);
end

function best_shift = find_best_shift_envelope(data_diff, sim_diff, shift_step, max_shifts, smooth_coeff)
    % Function to find the best shift using envelope correlation
    
    max_corr = -Inf;
    best_shift = 0;

    for i = 1:max_shifts
        shifted_data = circshift(data_diff, i * shift_step);
        score = envelope_correlation(shifted_data, sim_diff,smooth_coeff);  % Use the envelope correlation function

        if score > max_corr
            max_corr = score;
            best_shift = i * shift_step;
        end
    end

    fprintf('Best shift: %d samples (Envelope Correlation: %.4f)\n', best_shift, max_corr);
end

function [corr_score,env1,env2] = envelope_correlation(data1, data2,smooth_coeff)
    % Compute the envelope of both signals
    [env1, ~] = envelope(data1, 10, 'peak');
    [env2, ~] = envelope(data2, 10, 'peak');

    % Smooth envelopes
    windowSize = smooth_coeff;
    b = (1/windowSize) * ones(1, windowSize);
    a = 1;
    env1 = filter(b, a, env1);
    env2 = filter(b, a, env2);

    % Compute correlation
    corr_score = corr(env1, env2, 'Type', 'Spearman');  % Spearman correlation for trend matching
end


%% Function: Optimize k and sigma
function [best_k, best_sigma, best_corr] = optimize_parameters(data_diff, mdl,stim, k_values, sigma_values, smooth_coeff)
    best_corr = -Inf;
    best_k = 0;
    best_sigma = 0;

    for k = k_values
        for sigma = sigma_values
            % Generate new select_fcn using k and sigma
            centre = 1.8;
            select_fcn = @(x,y,z) exp(-(y - centre).^2 / (2 * sigma^2)) .* (cos(k * (y - centre)));

            % Generate model
            plain = mk_image(mdl, 1, 'Hi');
            plain.fwd_model.stimulation = stim;
            press = plain;
            press.elem_data = 1 + elem_select(press.fwd_model, select_fcn);
            press.fwd_model.stimulation = stim;

            % Compute simulated difference
            plain_data = fwd_solve(plain);
            press_data = fwd_solve(press);
            sim_diff_test = abs(press_data.meas - plain_data.meas) / 10;

            % Compute envelope correlation
            corr_score = envelope_correlation(data_diff, sim_diff_test, smooth_coeff);

            % Check if this is the best correlation found
            if corr_score > best_corr
                best_corr = corr_score;
                best_k = k;
                best_sigma = sigma;
            end
        end
    end
    fprintf('Best k: %.2f, Best sigma: %.2f, Best correlation: %.4f\n', best_k, best_sigma, best_corr);
end
